# ConicAlg contains indeterminates a_1, ... a_{ConicAlg_rank} (and their conjugations)
ConicAlg_rank := 5;

## ConicAlg indeterminates

# i: Integer.
# Output: Name of the i-th indeterminate in ConicAlg
ConicAlgBasicIndetName := function(i)
	return Concatenation("a", String(i));
end;

# i: Integer.
# Output: Name of the conjugate of the i-th indeterminate in ConicAlg
ConicAlgBasicInvIndetName := function(i)
	return Concatenation("a", String(i), "'");
end;

# Returns the list of all strings which appear as indeterminate names in ConicAlg
_ConicAlgIndetNames := function()
	local ConicAlgIndetNames, i;
	ConicAlgIndetNames := [];
	for i in [1..ConicAlg_rank] do
		Add(ConicAlgIndetNames, ConicAlgBasicIndetName(i));
	od;
	for i in [1..ConicAlg_rank] do
		Add(ConicAlgIndetNames, ConicAlgBasicInvIndetName(i)); # Conjugation
	od;
	return ConicAlgIndetNames;
end;

ConicAlgIndetNames := _ConicAlgIndetNames();

# mRep: External rep of an element of ConicAlgMag.
# Output: The external rep of the conjugate of this element.
ConicAlgMagInvOnRep := function(mRep)
	local replaceByList, replaceList;
	mRep := reverseNonassocList(mRep);
	replaceList := [1..ConicAlg_rank];
	replaceByList := [ConicAlg_rank+1..2*ConicAlg_rank];
	return ReplaceInNonassocList(mRep, replaceList, replaceByList);
end;

_ConicAlgInvOnIndexList := function(list)
	local result, i;
	result := Reversed(list);
	for i in [1..Length(result)] do
		if result[i] > ConicAlg_rank then
			result[i] := result[i] - ConicAlg_rank;
		else
			result[i] := result[i] + ConicAlg_rank;
		fi;
	od;
	return result;
end;

# indexList: A list of integers i with 1 <= i <= 2*ConicAlg_rank
# Output: The minimal element (w.r.t. the lex order) in the equivalence class of indexList
# w.r.t. to the equivalence relation generated by the following transformations:
# 1. _ConicAlgInvOnIndexList(_) (because tr(a) = tr(a'))
# 2. swapListAtIndex(_, i) for every i (because tr(xy) = tr(yx)).
# The output is regarded as the canonical representative of this class.
_CanonicalIndexList := function(indexList)
	local i, minEntry, minEntryPositions, minEntryInv, minEntryInvPositions,
		candidates, indexListInv;
	indexListInv := _ConicAlgInvOnIndexList(indexList);
	# Find positions of minimal entries in indexList and indexListInv.
	# Only these position have to be considered for swapListAtIndex transformations.
	minEntry := infinity;
	minEntryPositions := [];
	minEntryInv := infinity;
	minEntryInvPositions := [];
	for i in [1..Length(indexList)] do
		# indexList
		if indexList[i] < minEntry then
			minEntry := indexList[i];
			minEntryPositions := [i];
		elif indexList[i] = minEntry then
			Add(minEntryPositions, i);
		fi;
		# indexListInv
		if indexListInv[i] < minEntryInv then
			minEntryInv := indexListInv[i];
			minEntryInvPositions := [i];
		elif indexList[i] = minEntryInv then
			Add(minEntryInvPositions, i);
		fi;
	od;
	# candidates is the list of all elements of the equivalence class which
	# could potentially be minimal.
	if minEntry < minEntryInv then
		candidates := List(minEntryPositions, j -> swapListAtIndex(indexList, j));
	elif minEntry > minEntryInv then
		candidates := List(minEntryInvPositions, j -> swapListAtIndex(indexListInv, j));
	else
		candidates := Concatenation(
			List(minEntryPositions, j -> swapListAtIndex(indexList, j)),
			List(minEntryInvPositions, j -> swapListAtIndex(indexListInv, j))
		);
	fi;
	return Minimum(candidates); # Minimum w.r.t. lex order
end;

## Definition of ConicAlgMag

ConicAlgMag := FreeMagmaWithOne(ConicAlgIndetNames);
ConicAlgMagElFam := FamilyObj(One(ConicAlgMag));
ConicAlgMagIndets := GeneratorsOfMagmaWithOne(ConicAlgMag);
ConicAlgMagBasicIndets := ConicAlgMagIndets{[1..ConicAlg_rank]};
ConicAlgMagInvIndets := ConicAlgMagIndets{[ConicAlg_rank+1..2*ConicAlg_rank]};

ConicAlgMagBasicIndet := function(i)
	return ConicAlgMagBasicIndets[i];
end;

# m: Element of ConicAlgMag.
# Output: Conjugate of m.
ConicAlgMagInv := function(m)
	return ObjByExtRep(FamilyObj(One(ConicAlgMag)), ConicAlgMagInvOnRep(ExtRepOfObj(m)));
	# local replaceList, replaceByList;
	# if not m in ConicAlgMag then
	# 	return fail;
	# fi;
	# m := reverseInMagma(m);
	# replaceList := Concatenation(ConicAlgMagBasicIndets, ConicAlgMagInvIndets);
	# replaceByList := Concatenation(ConicAlgMagInvIndets, ConicAlgMagBasicIndets);
	# return replaceInMagma(ConicAlgMag, m, replaceList, replaceByList);
end;